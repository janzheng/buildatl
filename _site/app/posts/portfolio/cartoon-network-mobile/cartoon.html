
<!DOCTYPE html> 
<html lang="en"> 
    <head> 
		<!-- this is a PROTOTYPE that shows CN mobile web behavior. Code is messy and dirty. -->
		
        <meta charset="utf-8"> 
        <title>CN Mobile Prototype</title> 
        <link rel="stylesheet" href="cartoon.css" type="text/css" media="screen"> 
		
        <meta name="apple-mobile-web-app-capable" content="yes"> 
		<meta name = "viewport" content = "width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0;" />  
		
        <link rel="apple-touch-icon-precomposed" href="Raphael.png"> 
        <script src="raphael.js"></script> 
		
		
		<script type="text/javascript">
			touchMove = function(event) {
			// Prevent scrolling on this element
			event.preventDefault();
			}
			
		</script>

        <script> 
			var _height = 420, _width = 320, initTabHeight = 387, paper;
			
			if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) {
			   __IPHONE = true;
			   console.log("iphone!");
			}else{ __IPHONE = false; }
			
			////////////////////////////////////
			// TAB FUNCTIONS 
			////////////////////////////////////
			var touchPane = function () {
				this.oy = this.attr("y");
				
				if(this.isOpen){tabClose(this)};
			},
			movePane = function (dx, dy) {
				//this.attr({x: this.ox + dx, y: this.oy + dy});
				this.attr({y: this.oy + dy});
				this.dy = dy;
			},
			releasePane = function () {
				curY = this.attr("y");
				var heightThreshold=(_height/2)-100;
				
				//pane momentum for sliding up; (thresholds will be different)
				//slide down tab if below threshold, otherwise slide up
				if(this.dy < 0) {
					//sliding up
					var heightThreshold=(_height/2)+70;
					if(curY>heightThreshold){
						this.animate({y: initTabHeight}, 500, ">");
					} else
						this.animate({y: 0}, 500, ">", function() {tabOpen(this);});
				} else {
					//sliding down
					var heightThreshold=(_height/2)-150;
					if(curY>heightThreshold){
						//close
						this.animate({y: initTabHeight}, 500, ">");
					} else
						//pop back up
						this.animate({y: 0}, 500, ">", function() {tabOpen(this);});
				}
			},
			
			
			////////////////////////////////////
			// OPENED TAB FUNCTIONS 
			////////////////////////////////////
			tabOpen = function(tab) {
				tab.isOpen = true;
			
				//overlay tab with two new images so interior is swipeable.
				var roof = 136, intH = 910, threshold = 100;
				tab.bg = _paper.rect(0,roof, 320, intH).attr({"fill":"#fff"});
				tab.interior = _paper.image("tabinterior2.png", 0, roof, 320, intH).attr({"clip-rect":"0,136,320,910"});
				//var top = _paper.image("tabtop.png", 0, -1, 320, roof);
				
				
				tab.interior.drag(function(dx, dy){
						/*move*/
						if( (this.oy + dy)<roof+threshold && (this.oy + dy + intH-60)>_height-threshold){
							this.attr({y: this.oy + dy});
							this.dy = dy;
						}
					}, function() {
					
						this.clearTimers = function() {
							//log("cleared? : " + this.momTimer);
							clearInterval(this.momTimer);
							this.momTimer = undefined;
							clearInterval(this.speedTimer);
							this.speedTimer = undefined;
							this.speed=0;
							this.dy=0;
							//log("cleared: " + this.momTimer);
						}
						
						/*touch*/
						//log("touched");
						this.oy = this.attr("y");
						this._dy = 0;
						
						try{
							this.clearTimers();
						}catch(err){}
						
						var pane = this;
						//need a constantly polling function for speed. Kill on release.
						pane.speedTimer = setInterval(
							function(){
								//calculating speed from differences in y over time
								speed = pane.dy - pane._dy;
								pane._dy = pane.dy;
								pane.speed = speed;
						}, 15);
		  
					}, function() {
						/*release physics*/
						log("release speed: " + this.speed);
						
						var pos = this.oy + this.dy + intH;
						//snap-back
						if((this.oy + this.dy + intH - 60)<_height) {
							log("snap bottom");
							this.animate({y: 0-intH+_height+60}, 300, ">");
						}else if ((this.oy + this.dy)>roof) {
							log("snap top");
							this.animate({y: roof}, 300, ">");
						}else {
							//momentum
							//note: don't handle momentum if we strike against a wall
							//to do this we need time between mousedown and mouseup, and the distance in y
							
							//kill the speed timer or your speed is 0
							clearInterval(this.speedTimer);
							this.speedTimer = undefined;
							//speed regulation
							
							var maxSpeed = 80;
							if(this.speed > maxSpeed) this.speed=maxSpeed;
							if(this.speed < maxSpeed*(-1)) this.speed=maxSpeed*(-1);
							log("regulated speed: " + this.speed);
							
							if(__IPHONE)
								this.speed=Math.floor(1.0*this.speed); //adjust speed for ip here
							
							if(this.speed >0 || this.speed <0) {
								var pane = this;
								pane.momTimer = setInterval(
									function(){
										//calculating speed from differences in y over time
										
										//log("bump: " + pane.speed);
										
										//do these if you're moving and within the borders
										if(pane.speed!=0) {
											//log(pane.attr("y") + intH - 60);
											pane.momAni = pane.animate({y: pane.attr("y")+pane.speed}, 50);
											if(pane.speed>0){pane.speed--;}
											else if(pane.speed<0){pane.speed++;}
												//log("momentuming at " + pane.speed);
												
											//if outside boundaries, slow it down the farther it goes
											if ((pane.attr("y")>roof) || (pane.attr("y") + intH - 60<_height)){
												pane.speed = Math.floor(pane.speed * 0.7);
												
												//add a wall so you don't go way outside boundary
												if((pane.attr("y") + intH)<_height-threshold) {
													pane.speed=0;
												}else if (pane.attr("y")>roof+threshold) {
													pane.speed=0;
												}
											}
										}
										//if we're not moving and out of frame, then perform snap back
										else if((pane.attr("y") + intH - 60)<=_height) {
												pane.animate({y: 0-intH+_height+60}, 300);
												pane.clearTimers();
										}else if ((pane.attr("y"))>roof) {
											pane.animate({y: roof}, 300);
												pane.clearTimers();
										}else if(pane.speed == 0){
											pane.clearTimers();
											//if(!(momTimer==undefined)){clearInterval(momTimer)};
										}
									}, 50);
							}
						}
						
					});
				
				
				/*
				//top.click((function(event, interior, top){log(interior + ", " + top + " clicked");})(interior, top));
				top.mousedown( 
					function(event){ 
						//remove the top layers
						interior.remove(); 
						top.remove(); 
						
						//apply these physics to the original tab
						//tab.remove();
					}
				);
				*/
			},
			//run when user taps to close the tab, by tapping the tab.
			tabClose = function(tab) {
				tab.bg.remove();
				tab.interior.remove();
				log("closing the tab.");
				//tabClose.drag(movePane, touchPane, releasePane);
			};
				
			
			//////////////////////////////////////
			// HOME SCREN FUNCTIONS
			//////////////////////////////////////
			var touchHome = function () {
				this.oy = this.attr("y");
			},
			moveHome = function (dx, dy) {
				this.attr({y: this.oy + dy});
				this.dy = dy;
			},
			releaseHome = function () {
				this.animate({y: 0}, 300, ">");
			}
			
			var log = function(x) {
				console.log(x);
			}
				
			window.onload = function () {
			
				setTimeout(function(){
					// Hide the address bar!
					window.scrollTo(0, 1);
				}, 0);
  

				//320x416 is formatted for iOS w/o address bar and fitted 100% in web mode
				//this does NOT work for app / fullscreen mode- we should detect for this and set the paper size separately
				//var paper = Raphael(0,0, 320, 416);
				_paper = new Raphael(0,0, 320, 480);
				var home = _paper.image("homepage_bg.png", 0, -1, 320, 480);
				var tab = _paper.image("tab2_fixinterior.png", 0, initTabHeight , 320, 750);
				tab.isOpen = false;
				tab.drag(movePane, touchPane, releasePane);
				
				home.drag(moveHome, touchHome, releaseHome);
			};
        </script> 
    </head> 
    <body> 
 
    </body> 
</html>